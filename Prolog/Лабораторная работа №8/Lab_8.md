# Лабораторная 8 по курсу ФЛП.

Во второй части задачи 2 будьте готовы объяснить, почему сечения расставлены именно так, и как изменится работа программы, если поставить их в других местах.

## Задания для всех вариантов:

4. Вернитесь к решениям лабораторных 6 и 7. Найдите, где можно расставить зелёные сечения для улучшения эффективности. Кроме того, возможно, что в некоторых случаях Prolog выдаёт неправильные дополнительные решения после отката (особенно в задачах 3 и 4 лабораторной 6). Если найдёте такие случаи, исправьте их с использованием сечений.

5. Определите предикат `unifiable(List, Term, Result)`, который возвращает список всех элементов List, которые можно сопоставить с Term, но _без_ конкретизации входящих переменных.
  
  ```
  ?- unifiable([X, b, t(Y)], t(a), List].
  List = [X, t(Y)] %% X = t(a) и t(Y) = t(a) удаются, b = t(a) -- нет
  ```

Подсказка: подумайте, чем отличаются `\+(\+(X = Y)) и X = Y`.

## Вариант 1:

1. Определите предикат `nu(X, Y)`, работающий так же, как `\+ (X = Y)`, без использования `\+` (используйте комбинацию ! и fail).
  
  ```
  ?- nu(X, X).
  No
  ?- nu(X, foo(Y)).
  No
  ?- nu(4, 5).
  Yes
  ```

2. Определите предикат `abs(X, Abs)`, который выполняется, если Abs = |X|, без использования сечений. После этого расставьте зелёные сечения так, чтобы улучшить программу.
  
  ```
  ?- abs(3, A).
  A = 3 
  ?- abs(-1, A).
  A = 1
  ```
  
3. Определите предикат `set_union(List1, List2, Result)`, собирающий в Result все элементы List1 и все элементы List2. Если элемент лежит одновременно и в List1 и в List2, то в Result он должен входить только один раз.
  
  ```
  ?- set_union([1,2,3,4,5], [3,5,6,7,8], X).
  X = [1, 2, 4, 3, 5, 6, 7, 8] 
  ```

## Вариант 2:

1. Определите предикат `neq(X, Y)`, работающий так же, как `\+ (X == Y)`, без использования `\+` (используйте комбинацию ! и fail).
  
  ```
  ?- neq(X, X).
  No
  ?- neq(X, Y).
  Yes
  ?- neq(4, 5).
  Yes
  ```

2. Определите предикат `split(List, Pos, NonPos)`, который выполняется, если Pos содержит все положительные числа в List в том же порядке, а NonPos содержит все отрицательные числа и 0, без использования сечений. После этого расставьте зелёные сечения так, чтобы улучшить программу.
  
  ```
  ?- split([1,2,-1,3,0], Pos, NonPos).
  Pos = [1,2,3], NonPos = [-1, 0]
  ```
  
3. Определите предикат `delete_all(List, X, Result)`, удаляющий все вхождения элемента X из списка List.
  
  ```
  ?- delete_all([1,2,3,4,3,5], 3, X).
  X = [1, 2, 4, 5] 
  ```

## Вариант 3:

1. Определите предикат `my_nonvar(X)`, работающий так же, как `\+ var(X)`, без использования `\+` (используйте комбинацию ! и fail).
  
  ```
  ?- my_nonvar(X).
  No
  ?- my_nonvar(1).
  Yes
  ?- my_nonvar(foo(X)).
  Yes
  ```

2. Определите предикат `my_ground(Term)`, выполняющийся, если Term не содержит переменных, без использования сечений. После этого расставьте зелёные сечения так, чтобы улучшить программу. Используйте встроенный предикат =.. (Functor(Arg1, Arg2, ..., ArgN) =.. [Functor, Arg1, Arg2, ..., ArgN]).
  
  ```
  ?- my_ground(X).
  No
  ?- my_ground(foo(X,3)).
  No
  ?- my_ground(foo(2,3)).
  Yes
  ```

3. Определите предикат `list_add(List, X, Result)`, который добавляет элемент X к списку List. Если List уже содержит X, то Result должен совпадать с List.
  
  ```
  ?- list_add([1,2,3,4,3,5], 3, X).
  X = [1,2,3,4,3,5]
  ?- list_add([1,2,3,4,3,5], 6, X).
  X = [1,2,3,4,3,5,6]
  ```

## Вариант 4:

1. Определите предикат `not_member(X, List)`, истинный, если X не содержится в списке List, без использования `\+` (используйте предикат member, и комбинацию ! и fail).
  
  ```
  ?- not_member([1,2,3,4], 2).
  No
  ?- not_member([], 5).
  Yes
  ```

2. Определите предикат `delete_first(List, X, Result)`, удаляющий из List первое вхождение элемента X.
  
  ```
  ?- delete_first([1,2,3,4,3,5], 3, X).
  X = [1, 2, 4, 3, 5] 
  ```

3. Определите предикат `set_diff(List1, List2, Result)`, находящий все элементы списка List1, которые не входят в List2.
  
  ```
  ?- set_diff([1,2,3,4,3,5], [2,3,6], X).
  X = [1, 4, 5] 
  ```