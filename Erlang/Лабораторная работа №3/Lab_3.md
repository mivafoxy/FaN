# Лабораторная 3 по курсу ФЛП.

Обозначения типов в программах на Erlang можно найти в главе 6 [Reference Manual](http://www.erlang.org/doc/reference_manual/typespec.html). В заданиях применяется несколько упрощённая система обозначений, но рекомендуется познакомиться с настоящими обозначениями и применить их в задании 2.

БДП -- бинарное дерево поиска -- такое бинарное дерево (см. bin_tree.erl), у которого в левом поддереве любой вершины все данные меньше, чем в этой вершине, а в правой все данные больше. В задании 1 во всех вариантах деревья (как в аргументах, так и в возвращаемых значениях) -- БДП. 

В заданиях 1 и 3 запрещено сопоставлять с образцом непосредственно значения абстрактных типов! То есть вместо

```erlang
case Tree of 
  empty -> ...
  {node, Data, Left, Right} -> ...
end
```

следует использовать

```erlang
case view(Tree) of 
  empty -> ...
  {node, Data, Left, Right} -> ...
end
```

Это позволяет (теоретически) использовать другую реализацию этого интерфейса.

В задании 2 под интерфейсом понимается набор функций, необходимый для создания значений определяемоготипа и работы с ними. Для каждой функции должны быть указаны типы аргументов и возвращаемых значений, а также по возможности полно описано поведение. См. stack.erl для примера интерфейса и тестов АТД "стек".

## Обязательное задание для всех вариантов:

1. Оцените алгоритмическую сложность реализаций, созданных в задании 4. 

## Вариант 1:

1. Реализуйте функцию `split(bin_tree, any) -> {bin_tree, bin_tree}`. `split(Tree, X)` возвращает пару `{TreeLT, TreeGT}`, где `TreeLT` содержит все элементы Tree, меньшие X, а `TreeGT` -- все элементы, большие X.

2. Разработайте интерфейс для абстрактного типа данных ["множество"](http://ru.wikipedia.org/wiki/%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE_%28%D1%82%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%29). Множество позволяет хранить произвольное число значений без определённого порядка, при этом каждое значение хранится не более одного раза. 

3. Реализуйте над этим интерфейсом функцию `is_subset(set, set) -> bool`. `is_subset(Set1, Set2)` возвращает true, если `Set1` - подмножество `Set2` (т.е. все элементы Set1 содержатся в Set2).

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса. Каждая реализация в своём модуле.

## Вариант 2:

1. Реализуйте функцию `merge(bin_tree, bin_tree) -> bin_tree`. `merge(Tree1, Tree2)` возвращает дерево, содержащее все элементы Tree1 и Tree2.

2. Разработайте интерфейс для абстрактного типа данных ["мультимножество"](http://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%BE). Мультимножество позволяет хранить произвольное число значений без определённого порядка, при этом для каждого значение хранится также число раз, которое этот объект входит в мультимножество.

3. Реализуйте над этим интерфейсом функцию `union(multiset, multiset) -> bool`. `union(Multiset1, Multiset2)` возвращает мультимножество, содержащее все элементы Multiset1 и Multiset2, причём кратности элементов складываются (т.е. если X содержится 2 раза в MS1 и 3 раза в MS2, то оно содержится в union(MS1, MS2) 5 раз).

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса.

## Вариант 3:

1. Реализуйте функцию `flatten(bin_tree) -> list`. `flatten(Tree)` возвращает список всех данных в дереве в порядке возрастания.

2. Разработайте интерфейс для абстрактного типа данных ["словарь"](http://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%BE%D1%86%D0%B8%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2). Словарь позволяет хранить произвольное число пар ключ-значение без определённого порядка, при этом две пары с одним ключом одновременно не допускаются.

3. Реализуйте над этим интерфейсом функцию `all_values(dictionary) -> [any]`. `all_values(Dict)` возвращает список всех значений в словаре.

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса.

## Вариант 4:

1. Реализуйте функцию `count_leaves(bin_tree) -> integer`. `count_leaves(Tree)` возвращает число листьев дерева (т.е. вершин, у которых оба поддерева -- пустые).

2. Разработайте интерфейс для абстрактного типа данных ["очередь с приоритетом"](http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_%D1%81_%D0%BF%D1%80%D0%B8%D0%BE%D1%80%D0%B8%D1%82%D0%B5%D1%82%D0%BE%D0%BC). Очередь с приоритетом позволяет хранить пары (значение, приоритет), при этом каждое значение может храниться несколько раз (в том числе с одинаковым приоритетом) и поддерживает операцию извлечения пары с минимальным приоритетом.

3. Реализуйте над этим интерфейсом функцию `to_list(priority_queue) -> [any]`. `to_list(Queue)` возвращает список всех значений, содержащихся в Queue, в порядке возрастания приоритета.

4. Разработайте 1 (для частичного зачёта) или 2 реализации этого интерфейса.
