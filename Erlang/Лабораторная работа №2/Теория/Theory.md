# Система типов

## Динамическая сильная типизация

Erlang - это динамически типизированный язык. Все ошибки, связанные с типами, можно обнаружить только при выполнении программы, а не на этапе компиляции. 

Идеология Erlang: «Если оно сломалось — пусть ломается». Язык обладает инструментами, позволяющими изолировать и корректно обрабатывать все ошибки, которые могут возникнуть. Это делает программы на Erlang очень живучими. Классический пример живучести программ на Erlang, который приводят — ПО коммутаторов Ericsson AXD 301 ATM. Этот продукт имеет больше миллиона строк кода и аптайм 99.9999999%.

Erlang не стремится избегать ошибок. Он предлагает правильно их обрабатывать.

Так же Erlang относится к языкам с сильной типизацией. Это значит, что приведения типов нужно производить явно. При использовании в одном выражении несовместимых между собой типов данных можно получить ошибку:

```erlang
> 10 - "5".
** exception error: bad argument in an arithmetic expression
    in operator  -/2
        called as 10 - "5"
```

## Преобразование типов

Для преобразования типов в Erlang используются функции стандартной библиотеки (находятся в модуле Erlang). Имена этих функций формируются по следующей схеме: `<исходный_тип>_to_<небходимый_тип>`. Вот полный перечень таких функций:

- atom_to_binary/2
- atom_to_list/1
- binary_to_atom/2
- binary_to_existing_atom2
- binary_to_list/1
- bitstring_to_list/1
- binary_to_term/1
- float_to_list/1
- fun_to_list/1
- integer_to_list/1
- integer_to_list/2
- iolist_to_binary/1
- iolist_to_atom/1
- list_to_atom/1
- list_to_binary/1
- list_to_bitstring/1
- list_to_existing_atom/1
- list_to_float/1
- list_to_integer/2
- list_to_pid/1
- list_to_tuple/1
- pid_to_list/1
- port_to_list/1
- ref_to_list/1
- term_to_binary/1
- term_to_binary/2
- tuple_to_list/1

Пример использования:

```erlang
1> erlang:integer_to_list(123).
"123"
2> erlang:atom_to_list(false).
"false"
3> erlang:iolist_to_atom(123).
** exception error: bad argument
    in function  iolist_to_atom/1
        called as iolist_to_atom(123)
```

## Проверка типов

Большинство типов данных в Erlang можно отличить визуально. Списки заключаются в квадратные скобки, кортежи в фигурные, а строки в двойные кавычки и т.д. Благодаря этому обеспечивается простейшая проверка типов. Например, паттерн для сопоставления [x|xs] может быть сопоставлен только со списком. В противном случае операция закончится неудачей.

Но таких элементарных проверок недостаточно. Зачастую нужно проверить, к какому типу относится та или иная переменная. Для этого в Erlang есть ряд функций, которые принимают один аргумент (иногда больше) и если его тип соответствует ожидаемому, возвращают `true`, иначе `false`. Эти функции можно использовать в охранных выражениях и проверяемый ими тип понятен из их названия.

- is_atom/1
- is_binary/1
- is_bitstring/1
- is_boolean/1
- is_builtin/3
- is_float/1
- is_function/1
- is_function/2
- is_integer/1
- is_list/1
- is_number/1
- is_pid/1
- is_port/1
- is_record/2
- is_record/3
- is_reference/1
- is_tuple/1

В Erlang нет функции, которая возвращала бы тип переданной переменной (на подобии `type_of()`). И на первый взгляд это может показаться странным, ведь одна универсальная функция удобнее, чем куча узконаправленных. Ответ на этот вопрос кроется в идеологии языка: программа должна делать только то, что описано явно. Все остальное должно привести к ошибке.

Эти типы данных можно комбинировать между собой при помощи списков и кортежей для создания более гибких и универсальных типов.

# Функции высшего порядка

Важной частью всего функционального программирования является механизм передачи функции как аргумента в другую функцию. Таким образом, с переменными можно обращаться как с функциями изнутри других функций. Функция, принимающая на вход другую функцию, называется **функцией высшего порядка**.

Рассмотрим довольно странный пример:

```erlang
-module(high_functs).
-compile(export_all).

one() -> 1.
two() -> 2.

add(X, Y) -> X() + Y().
```

Теперь попробуем скомпилировать этот код и вызвать функцию из Erlang Shell:

```erlang
1> c(hhfuns).
    {ok, hhfuns}
2> high_functs:add(one,two).
    ** exception error: bad function one
      in function  hhfuns:add/2
3> high_functs:add(1,2).
    ** exception error: bad function 1
      in function  hhfuns:add/2
4> high_functs:add(fun high_functs:one/0, fun high_functs:two/0).
3
```

Синтаксис Erlang подразумевает, что раз у входных аргументов при обращении поставлены `(...)`, то происходит попытка вызова функций. В первом случае были переданы атомы, во втором - значения, и Erlang не понимает, что от него хотят. Чтобы передать функцию, нужно возспользоваться следующей конструкцией:

```erlang
fun Module:Function/Arity
```

С помощью нее функция присваивается переменной.

## Анонимные функции

Анонимные функции, или `funs`, позволяют объявлять функции прямо на ходу, без их наименования. Анонимные функции почти что ничем не отличаются от обычных, разве что нельзя в них рекурсивно вызвать самих себя. Синтаксис анонимных функций следующий:

```erlang
fun(Args1) ->
    Expression1, Exp2, ..., ExpN;
   (Args2) ->
    Expression1, Exp2, ..., ExpN;
   (Args3) ->
    Expression1, Exp2, ..., ExpN
end.
```

Пример использования:

```erlang
7> Fn = fun() -> a end.
#Fun<erl_eval.20.67289768>
8> Fn().
a
4> high_functs:add(fun(X) -> 1 end, fun(X) -> 2 end).
```

## Методы для работы с list

Много полезных функций высшего порядка определено в модуле `lists`:
- `all(Predicate, List)`
    - true, если Predicate (функция из элементов списка в true/false) возвращает true на всех элементах List
    - false, если Predicate возвращает false на каком-то элементе List

```erlang
lists:all(fun(X) -> X > 0 end, [1,-1,2]) => false
```

- `any(Predicate, List)`
    - true, если Predicate (функция из элементов списка в true/false) возвращает true на каком-то элементе List
    - false, если Predicate возвращает false на всех элементах List
 
```erlang
lists:any(fun(X) -> X > 0 end, [1,-1,2]) => true
```

- `dropwhile(Predicate, List)` - выбрасывает из List все начальные элементы, на которых Predicate возвращает true, и возвращает то, что осталось (т.е. часть списка, которая начинается с первого элемента, на котором предикат вернул false

```erlang
lists:dropwhile(fun(X) -> X > 0 end, [1,-1,2]) => [-1, 2]
```

- `filter(Predicate, List)` - возвращает список, состоящий только из тех элементов List, на которых Predicate возвращает true

```erlang
lists:filter(fun(X) -> X > 0 end, [1,-1,2]) => [1, 2]
```

- `foldl(Fun, Accumulator, List)` - сворачивает список. Fun -- функция от двух аргументов, первый -- элемент из списка, второй -- значение Accumulator, возвращает новое значение для Accumulator. Когда в списке не остаётся элементов, foldl возвращает значение Accumulator. Реализацию см. в lists2.erl. foldr -- аналогично, но пробегает список справа налево.

```erlang
lists:foldl(fun(X, Acc) -> X + Acc end, 0, [1,2,3]) => 6
```

- `foreach(Fun, List)` - вызывает Fun на каждом элементе в списке и отбрасывает результат

- `map(Fun, List)` - возвращает список, состоящий из результатов применения Fun к каждому элементу List

```erlang
lists:map(fun(X) -> X > 0 end, [1,-1,2]) => [true, false, true]
```

- `partition(Predicate, List)` - возвращает пару списков. Первый состоит из элементов List, на которых Predicate вернул true, второй -- из тех, на которых он вернул false.

```erlang
lists:partition(fun(X) -> X > 0 end, [1,-1,2]) => {[1,2], [-1]}
```

- `sort(Fun, List)` - возвращает список List, отсортированный с помощью отношения порядка Fun. Fun(X, Y) возвращает true, если X меньше или равно Y, и false
  в противном случае.

```erlang
lists:sort(fun(X, Y) -> length(X) <= length(Y), [[1],[1,1],[]]) => [[],[1],[1,1]]
```

`takewhile(Predicate, List)` - возвращает максимальный начальный отрезок List, на всех элементах которого Predicate возвращает true

```erlang
lists:takewhile(fun(X) -> X > 0 end, [1,-1,2]) => [1]
```

- `zipwith(Fun, List1, List2)` - возвращает список, состоящий из результатов применения Fun к парам элементов List1 и List2, стоящим на одинаковых местах. Если один из списков длиннее, "лишние" элементы отбрасываются.

```erlang
lists:zipwith(fun(X, Y) -> X+Y end, [1,2,3,4], [4,5,6]) => [5,7,9]
```

И т.д.

# Ссылки на источники

1. [Erlang для самых маленьких. Глава 4: Система типов](https://habr.com/ru/post/230551/).
2. [Higher Order Functions](https://learnyousomeerlang.com/higher-order-functions).
