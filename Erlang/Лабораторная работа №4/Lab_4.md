# Лабораторная 4 по курсу ФЛП.

Перед выполнением работы нужно знать хотя бы материал главы [Processes в Erlang User's Guide](http://www.erlang.org/doc/reference_manual/processes.html). Ещё один хороший источник - [главы](http://learnyousomeerlang.com/content) с The Hitchhiker's Guide to Concurrency до Errors and Processes.

Минимум для сдачи лабораторной -- задача 1.

## Задача 2 (общая для всех вариантов, делать после задачи 1).

Реализуйте модуль `parent_children`: 
1. `start(N::integer())` запускает N+1 процесс: "родитель" и N "детей". Каждый из детей ждёт сообщений. Если получено сообщение stop, процесс останавливается без ошибки; если получено сообщение die, процесс падает с ошибкой; любое другое сообщение печатается в оболочке. В случае, если один из детей умрёт с ошибкой, родитель его перезапускает и печатает сообщение об этом. Если родитель умирает, все дети тоже должны умереть.
2. `send_to_child(I::integer(), Msg::any())` посылает родителю сообщение, после которого он пересылает Msg ребёнку номер I.
3. `stop()` останавливает родителя.

Параметр Options в задаче 3 всех вариантов -- список, который может содержать следующие элементы: {sublist_size, integer()} (размер частей, на которые разбивается список), {processes, integer()} (число процессов, которые обрабатывают части списка), {timeout, Milliseconds::integer()|infinity} (максимальное время, за которое функция должна закончить работу). При отсутствии sublist_size в каждой части списка 1 элемент. При отсутствии processes каждая часть обрабатывается отдельным процессом. Для работы с такими списками можно использовать модуль proplists.

## Дополнительные задания:

1. **ПРЯМО НУ ОЧЕНЬ ДОПОЛНИТЕЛЬНО, ИЗ ИНТЕРЕСА** Познакомиться с OTP, и оформить решение задач 1 и 2 как OTP-приложение.

2. **(кроме варианта 3)**. То же, что задание 3, но элементы должны возвращаться в том же порядке. 

3. **(только вариант 3)**. Реализуйте функцию par_sort(List, Options), которая сортирует список параллельно с помощью сортировки слиянием. Слияния должны также происходить параллельно.

## Вариант 1:

1. Реализуйте функцию `ring(N, M)`, которая создаёт N процессов и посылает сообщение первому процессу, который посылает сообщение второму, второй - третьему, и так далее. Наконец, процесс N посылает сообщение обратно процессу 1. После того, как сообщение обежало вокруг кольца M раз, все процессы должны закончить работу. Все события выводятся в оболочке с помощью io:format. Пример работы (конкретные PID будут отличаться):

```erlang
> ring:ring(3, 2).
Current process is <0.31.0>
Created <0.33.0>
Created <0.34.0>
Created <0.35.0>
<0.33.0> received 0 from <0.31.0> 
<0.34.0> received 1 from <0.33.0>
<0.35.0> received 1 from <0.34.0>
<0.33.0> received 2 from <0.35.0>
<0.33.0> finished
<0.34.0> received 2 from <0.33.0>
<0.34.0> finished
<0.35.0> received 2 from <0.34.0>
<0.35.0> finished
```

3. Реализуйте функцию `par_filter(F, List, Options)`, которая возвращает список с теми же элементами, что `lists:filter(F, List)` (но не обязательно в том же порядке).

## Вариант 2:

1. Реализуйте функцию `star(N, M)`, которая создаёт N+1 процессов (1 "центральный" и N "крайних") и посылает сообщение центральному процессу, который посылает сообщение всем остальным процессам и дожидается от них ответа, после чего это повторяется (всего M раз). После того, как все сообщения получены, все процессы должны закончить работу. Все события выводятся в оболочке с помощью `io:format`. Пример работы (конкретные PID и порядок строк будут отличаться):

```erlang
> star:star(3, 2).
Current process is <0.31.0>
Created <0.33.0> (center)
Created <0.34.0>
Created <0.35.0>
Created <0.36.0>
<0.33.0> received 0 from <0.31.0> 
<0.34.0> received 1 from <0.33.0>
<0.33.0> received 1 from <0.34.0>
<0.35.0> received 1 from <0.33.0>
<0.36.0> received 1 from <0.33.0>
<0.33.0> received 1 from <0.35.0>
<0.33.0> received 1 from <0.36.0>
<0.34.0> received 2 from <0.33.0>
<0.34.0> finished
<0.35.0> received 2 from <0.33.0>
<0.33.0> received 2 from <0.35.0>
<0.35.0> finished
<0.36.0> received 2 from <0.33.0>
<0.33.0> received 2 from <0.36.0>
<0.33.0> received 2 from <0.34.0>
<0.36.0> finished
<0.33.0> finished
```

3. Реализуйте функцию `par_foreach(F, List, Options)`, которая работает так же, как `lists:foreach(F, List)`  (но параллельно). Заметьте, что закончить работу можно только тогда, когда функция F применена ко всем значениям в List!

## Вариант 3:

1. Реализуйте процесс-"эхо", который ожидает сообщения и 1) если получен атом stop, то он заканчивает работу; 2) если получено {print, Term}, то выводит Term в оболочке.
Для удобства использования модуль должен предоставлять интерфейс

```erlang
echo:start() => ok
echo:print(Term) => ok
echo:stop() => ok
```

Пример работы:

```erlang
> echo:start().
Started <0.33.0>
ok
> echo:print(1).
1
ok
> echo:print(stop).
stop
ok
> echo:stop().
Stopped!
ok
```

3. Реализуйте функцию `par_partition(F, List, Options)`, которая возвращает пару списков с теми же элементами, что `lists:partition(F, List)` (но не обязательно в том же порядке).

## Вариант 4:

1. Реализуйте процесс-"счётчик", который запускается со значением 0 и 1) если получен атом stop, то он выводит в оболочке текущее значение и заканчивает работу; 2) если получено любое другое сообщение, то значение увеличивается на 1 и выводится сообщение об этом. Для удобства использования модуль должен предоставлять интерфейс

```erlang
counter:start() => ok
counter:incr() => ok
counter:stop() => ok
```

Пример работы:

```erlang
> counter:start().
Started <0.33.0>
ok
> counter:incr().
Incremented counter value (now 1)
ok
> counter:incr().
Incremented counter value (now 2)
ok
> counter:stop().
Stopped!
ok
```

3. Реализуйте функцию `par_map(F, List)`, которая возвращает список с теми же элементами, что `lists:map(F, List)` (но не обязательно в том же порядке).
