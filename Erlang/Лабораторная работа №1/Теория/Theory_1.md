# Среда, типы данных, переменные, списки и кортежи

## Введение

Для работы с языком `Erlang` понадобятся:

1. [Erlang Shell](https://www.erlang.org/downloads).
2. Редактор кода, например, [VSCode](https://code.visualstudio.com/).
    1. Если решили воспользоваться редактором кода `VSCode`, то рекомендуется установить надстройку [Erlang из MarketPlace](https://marketplace.visualstudio.com/items?itemName=pgourlain.erlang).

`Erlang` - это интерпретируемый язык программирования. В `Erlang Shell` можно построчно записывать команды, каждая из которых является **выражением**. В отличии от большинства языков, в конце выражения ставится точка, а не точка с запятой.

Запуск примеров производится из `Erlang shell`.

## Набор команд

Для того, чтобы узнать, в какой директории сейчас находится `Erlang shell`, можно воспользоваться функцией `pwd().`

```erlang
> pwd().
c:/Program Files/Erlang OTP/usr
ok
```

Чтобы перейти в другую директорию, можно воспользоваться функцией `cd(...).`

```erlang
> cd("C:/Source/Erlang/ErlangMIET").
c:/Source/Erlang/ErlangMIET <- в случае успешного перехода выведет ту директорию, в которую он планировался.
ok
```

Курс расчитан на выполнение лабораторных работ таким образом, чтобы студент писал код в файлах с расширением `*.erl`. Чтобы выполнить код файла из `Erlang Shell`, необходимо передавать название **модуля, а не файла** в команду `c().`.

```erlang
> c("ModuleName").
{ok,ModuleName} <- выведется при переводе в байт-код без ошибок.
```

Более подробный рассмотр выполнении кода из `*.erl` будет в главе **Модули и функции**.

## Типы данных

### Числа

Erlang поддерживает два типа численных переменных: *целые* и *числа с плавающей точкой*. Erlang поддерживает операции:
- сложения

```erlang
> 7 + 3.
10 
```

- вычитания

```erlang
> 12 - 4.
8
```

- умножения

```erlang
> 5 * 2.
10
```

- деления 

```erlang
> 12 / 6 <- результат будет число с плавающей запятой.
2.0
> 7 div 3. <- работает только с целыми числами.
2
```

- поиска остатка от деления.

```erlang
> 7 rem 3.
1
```

Erlang позволяет производить несколько математических операций за раз, подчиняются они стандартным правилам приоритета.

```erlang
> 2 + 3 * 4.
14
> (2 + 3) * 4.
20
> -(10 + 3).
-13
```

К тому же, необязательно ограничиваться только десятичной системой счисления. Можно использовать числа с любым основанием от 2 до 36. Для этого число необходимо указывать в виде `Base#Value`.

```erlang
> 2#11011.
27
> 10#1198.
1198
> 16#A04F.
41295
> 36#1TA.
2350
```

Но и это еще не все. В Erlang можно использовать числа с разными основаниями в одном выражении:

```erlang
> 2#11011 + 36#1TA.
2377
> 10#1198 - 16#A04F.
-39841
> 3#201 * 4#321.
1083
```

### Атомы

**Атомы** — это аналог именованных констант из других языков, причем значение атома в точности соответсвует его названию. Грубо говоря, атом — *это строка, которую нельзя изменить*.

Атомы должны начинаться со строчной буквы и могут содержать в себе строчные и заглавные буквы, цифры, знак подчеркивания(_) и собаку(@). Так же атом можно заключить в одинарные кавычки и тогда он может включать в себя любые символы.  Атом не может совпадать с зарезервированным словом языка.

**Недопустимые атомы:** `after and andalso band begin bnot bor bsl bsr bxor case catch cond div end fun if let not of or orelse query receive rem try when xor`.

```erlang
> atom.
atom
> otherAtom.
otherAtom
> atom_with_underscore.
atom_with_underscore
> one@more@atom.
one@more@atom
> 'Atom with whitespace'.
'Atom with whitespace'
> ' Atom with special charactes #^&?'.
' Atom with special charactes #^&?'
> Atom.
* 1: variable 'Atom' is unbound
> after.
* 1: syntax error before: 'after'
```

### Логические типы данных и операторы сравнения

Под булевы типы данных в Erlang зарезервированы два атома: `true` и `false`. Язык поддерживает все основные логические операции, такие как "и" (`and`), "или" (`or`), "исключающее или" (`xor`), "отрицание" (`not`).

```erlang
> true or false.
true
> true and false.
false
> true xor false.
true
> not false.
true
> (not (true xor true)) or (false and true).
true
```

Операторы `and` и `or` всегда вычисляют значения выражений с обеих сторон от себя. Поэтому при выполнении кода `(1 > 2) or (3 < 4).` будут найдены значения обоих выражений, хотя после вычисления правого выражения результат уже известен. Если необходимо избежать это, используйте операторы `andalso` и `orelse`.

Для сравнения значений между собой используются операторы "равно"(`==`), "соответсвенно равно"(`=:=`), "соответственно неравно"(`=/=`), "неравно"(`/=`), "меньше"(`<`), "меньше или равно"(`=<`), "больше"(`>`) и "больше или равно"(`>=`).

Операции "соответственно ..." также проверяют еще и типы.

```erlang
> 2 == 2.0.
true
> 2 =:= 2.0.
false
> 3 /= 3.0.
false
> 3 =/= 3.0.
true
> 5 > 5.
false
> 5 =< 5.
true
```

Следует обратить внимание на следующий пример:

```erlang
> true == 1.
false
> false == 0.
false
> false > 19. %% !!!
true
```

Третья строка выдает в результате что-то необычное. Дело все в том, что `Erlang` позволяет сравнивать значения разных типов и при сравнении руководствуется следующим правилом: `число(number) < атом(atom) < ссылка(reference) < функция(fun) < порт(port) < процесс(pid) < кортеж(tuple) < список(list) < битовая строка(bit string)`. `true` и `false` — атомы, а из приведенного выражения видно, что атомы «больше» чисел. Поэтому и получается, что `false > 19`.

## Переменные

Erlang позволяет создавать переменные, но с одним ограничением: значение переменной может быть присвоено только один раз. Повторное присвоение значения вызовет ошибку.

Имя переменной должно начинаться с заглавной буквы или знака подчеркивания(_). Имя переменной может состоять из одного только знака подчеркивания. Но переменная с таким именем не запоминает значение. Такие переменные используются для сопоставления с образцом (об этом смотрите далее).

```erlang
> Variable = 10 - 7.
3
> OtherVariable = 3 * 4.
12
> _result = Variable + OtherVariable.
15
> _result.
15
> Variable = 5.
** exception error: no match of right hand side value 5
```

## Кортежи

Иногда группу переменных, которые каким-либо образом связаны между собой, удобнее хранить вместе. Для этого Erlang предоставляет такую конструкцию, как кортеж. Кортеж имеет следующий вид: `{Value1, Value2, ..., ValueN}` и может содержать любое количество переменных.

**Пример:** необходимо хранить информацию о точке на координатной плоскости (координаты X и Y). Можно завести две отдельных переменных и хранить координаты в них, но проще хранить их вместе.

```erlang
> MyPoint = {2,5}.
{2,5}
```

Размер кортежа не ограничивается двумя значениями. Так же кортеж может содержать значения разных типов, в том числе и другие кортежи.

```erlang
> MyTuple = {1,myAtom,true,{1,false}}.
{1,myAtom,true,{1,false}}
```

## Сопоставление с образцом

Для извлечения значений из кортежа (и не только для этого) используется **сопоставление с образцом**. Как работатет оператор сопоставления(`=`): Он берет значения справа и сопоставляет их с переменными, находящимися слева. То есть, это то же самое присваивание из императивных языков с одним лишь отличием: **сопоставить возможно только несвязанные переменные**, т.е. те у которых еще нет значения.

*Сопоставление с образцом* — это когда вместо одиночной переменной указывается "шаблон", который должен соотвествовать данным. И если данные соответствуют шаблону, то переменные из этого шаблона будут сопоставлены с соответствующими значениями.

```erlang
> {X,Y} = {1,2}.
{1,2}
> X.
1
> Y.
2
> Z = {Y,X}.
{2,1}
> {A,B,C} = {myAtom,true,Z}.
{myAtom,true,{2,1}}
> A.
myAtom
> B.
true
> C.
{2,1}
```

*Сопоставление с образцом* — один из самых мощных инструментов функциональных языков и используется не только для извлечения данных из кортежей. Далее, мы будем использовать этот прием довольно часто.

Не всегда нужны все данные. К примеру, может понадобиться только второе значение тройки (тройка — это кортеж из трех значений). Что бы не «плодить» бесполезные сущности, можно использовать cпециальную переменную, о которой гвоорилось раньше: _. Тем самым можно указать, что в этом месте шаблона должно быть некое неиспользуемое значение. Причем в шаблоне может быть несколько таких переменных.

```erlang
> {_,X,_} = {1,2,3}.
{1,2,3}
> X.
2
```

## Списки

В Erlang список можно считать аналогом массивов, но под капотом это в самом деле односторонний связный список. Ещё одним важным отличием от списков/массивов из императивных языков является то, что члены списка в Erlang не обязаны быть одного типа. Один список может содержать числа, атомы, кортежы, другие списки и т.д.

```erlang
> [1,2,true,atom,{5,4},[true,false]].
[1,2,true,atom,{5,4},[true,false]].
```

При работе со списками в Erlang есть один странный момент:

```erlang
> [100,101,102,103].
"defg"
```

Erlang вывел список в виде строки. Не стоит волноваться. Это касается только его отображения в терминале. На самом деле список все так же содержит числа. Такое поведение связанно с особенностями происхождения языка. Изначально в Erlang не было строк. И для работы с ними использовали списки, которые хранили номера символов. К счастью, язык развивается и сегодня есть возможность нормально работать со строками.

Списки можно складывать (`++`) и вычитать друг из друга(`--`). Эти операторы тоже правоассоциативны.

```erlang
> [1,2,3,4,5] ++ [6,7].
[1,2,3,4,5,6,7]
> [1,2,3,4,5] -- [2,3].
[1,4,5]
> [1,2,3] ++ [].
[1,2,3]
> [1,2,3,4,5] -- [1,2,3] -- [3].
[3,4,5]
> [1,2,3] ++ [4,5,6] -- [4,5].
[1,2,3,6]
```

Так же списки можно сравнивать между собой. Для этого используются стандартные операторы сравнения. Сначала сравниваются головы списков. Если они равны, то сравниваются головы хвостов и т.д. Списки сравниваются по первым различным элементам. В приведенном ниже примере первый список больше потому, что первый элемент, который отличается от соответствующего элемента второго списка больше (`4 > 1`).

```erlang
> [1,2,3,4,0] > [1,2,3,1,1000,2000,6589].
true
```

Списки делятся на две части: голову(`head`) и хвост(`tail`). *Голова* — это первый элемент списка, а *хвост* — все остальное. У хвоста, в свою очередь, тоже есть голова и хвост. При сопоставлении с образцом используется оператор `|`, что бы указать, где проходит граница между головой и хвостом.

```erlang
> [Head|Tail] = [1,2,3,4,5].
[1,2,3,4,5]
> Head.
1
> Tail.
[2,3,4,5]
> [Second|_] = Tail.
[2,3,4,5]
> Second.
2
```

## Генератор списков

Erlang имеет инструмент для автоматического создания списков. Принцип его работы лучше всего рассматривать на примере. В коде ниже автоматически составляется список, который будет содержать в себе числа от 1 до 10, умноженные на 3.

```erlang
> [X*3 || X <- [1,2,3,4,5,6,7,8,9,10]].
[3,6,9,12,15,18,21,24,27,30]
```

Выражение имеет вид `[Expr || Item <- SourceList]`. Erlang поочередно берет каждый элемент из *SourceList* и подставляет его в выражение *Expr*, на место переменной *Item*. Результат этого выражения добавляется в результирующий список.

Усложненный пример, в котором генератор будет работать только с четными числами из исходного списка.

```erlang
> [X*3 || X <- [1,2,3,4,5,6,7,8,9,10], X rem 2 =:= 0, X > 5].
[18,24,30]
```

Теперь генератор имеет вид `[Expr || Item <- SourceList, Condition1, Condition2, ..., Condition2]`. Работает он в точности, как и первый вариант, но теперь Erlang проверяет, чтобы каждый элемент исходного списка подходил под указанные условия. Если элемент не подходит хотя бы под одно — он пропускается.

Исходных списков может быть несколько. Ниже пример генератора, который вернет все возможные комбинации четных чисел от 1 до 5 и нечетных чисел от 6 до 10. Пусть комбинация будет представлена кортежем из двух элементов — парой.

```erlang
> [{X,Y} || X <- [1,2,3,4,5], Y <- [6,7,8,9,10], X rem 2 =:= 0, Y rem 2 =:= 1].
[{2,7},{2,9},{4,7},{4,9}]
```

В самом общем случае генератор имеет вид `[Expr || Item1 <- SourceList1, Item2 <- SourceList2, ..., ItemN <- SourceListN, Condition1, Condition2, ..., ConditionN]`. В этом случае Erlang вернет декартово произведение исходных списков (точнее их элементов, которые подойдут под условия).

# Модули и функции

В Erlang все функции разбиты на модули, ни одна из них не может быть исключением. Стандартные (глобальные) функции языка в самом деле также находятся внутри модуля. Это `BIF` - Built-In Functions, принадлежащие языку Erlang. BIF импортируется по умолчанию, поэтому с ними можно работать как с отдельными функциями.

## Модули

В Java есть пакеты, в C# - пространства имен, а в erlang это модули. Модуль содержит в себе группу логически связанных функций. Модуляризация необходима для объединения функций, имеющих схожее значение. К примеру, функции для работы со списками находятся в модуле `lists`, а функции ввода-вывода в модуле `io`.

Синтаксис вызова функции из модуля через Erlang Shell или в коде `*.erl` файла следующий:

```erlang
ModuleName:FunctionName(Arg1, Arg2, ..., ArgN)
```

Пример вызова функции, которая возвращает элемент кортежа с указанным номером:

```erlang
> erlang:element(3, {23,54,34,95}).
34
```

### Атрибуты модуля

Атрибутами модуля являются его название, версия, автор, список импортируемых функций и т.д. Рассмотрим некоторые из них:

1. `-module(Name).` - название модуля. **Обязательный атрибут**, который должен быть уканаз **первым**. Без него компиляция модуля невозможно. В качестве аргумента принимается атом - название модуля.
2. `export([Fnct1/Arity, Fnct2/Arity, ..., FnctN/Arity])` - список экспортируемых функций, т.е. тех, которые будут доступны извне для вызова. Принимаемый атрибут - список функций, где `Fnct` - наименование функции, а `Arity` - количество аргументов, принимаемых ей (*арность*).
3. `-import(ModuleName, [Fnct1/Arity, Fnct2/Arity, ..., FnckN/Arity]).` - импорт модуля и необходимых функций из него. Каджый импортируемый модель указывается в отдельном атрибуте. Импорт позволяет обращаться к функциям не через полное имя `ModuleName:FunctionName(...)`, а только через `FunctionName(...)`. Аналог - `using` в C# или `import` в Java.

Полный список атрибутов есть в [официальной документации](https://www.erlang.org/doc/reference_manual/modules.html).

Для примера, можно создать файл `Example.erl`, в котором можно определить атрибуты:

```erlang
%% Содержимое файла Example.erl
-module(example).
-export([add/2, subtr/2, mult/2, divis/2]). %% вместо export можно использовать -compile(export_all).
-import(io, [format/2]).
```

Пока что модуль `example` не будет скомпилирован по одной причине - в export указан набор функций, которые в модуле пока что не определены.

```erlang
> c(example).
example.erl:4:2: function add/2 undefined
%    4| -export([add/2, subtr/2, mult/2, divis/2]).
%     |  ^

example.erl:4:2: function divis/2 undefined
%    4| -export([add/2, subtr/2, mult/2, divis/2]).
%     |  ^

example.erl:4:2: function mult/2 undefined
%    4| -export([add/2, subtr/2, mult/2, divis/2]).
%     |  ^

example.erl:4:2: function subtr/2 undefined
%    4| -export([add/2, subtr/2, mult/2, divis/2]).
%     |  ^
```

## Функции

В самом базовом случае объявление функций в Erlang происходит по следующему синтаксису:

```erlang
FnctName(Arg1, Arg2,..., ArgN) -> FunctionBody.
```

Имя функции - это атом, а ее тело состоит из одного или нескольких выражений, разделенных **запятыми**. В конце тела функции **ставится точка**. В случае, если функция содержит лишь одно выражение, стоит записать ее в одну строчку.

```erlang
add(X, Y) -> X + Y.
```

Функция `add` принимает два аргумента на вход и возвращает их сумму. `return` - отсутствует, причина в том, что в Erlang функция **всегда имеет возвращаемое значение**, им будет результат последнего выражения в теле функции.

Функция не всегда состоито из одного выражения. В таком случае форматирование должно быть подобно примеру ниже:

```erlang
add(X, Y) ->
    doSomething(),
    X + Y.
```

После добавления оставшихся функций модуль можно будет успешно скомпилировать.

## Компиляция

Программы, написанные на Erlang, компилируются в промежуточный байт код, который потом выполняется в виртуальной машине. Благодаря этому приложения написанные на Erlang кроссплатформенны.

Существует несколько виртуальных машин для Erlang. Но самая распространенная — это BEAM(Bogdan/Björn's Erlang Abstract Machine). Существует еще ряд виртуальных машин (JAM и WAM), но они почти не используются.

Скомпилировать модуль можно при помощи команды `c(ModuleName).`

```erlang
> c(example).
{ok,example}
```

В результате компиляции рядом с файлом `*.erl` появится файл `ModuleName.beam`, который является скомпилированным модулем. Пример вызова функций из него:

```erlang
> example:add(3,4).
7
> example:subtr(4,23).
-19
> example:mult(3,3).
9
> example:divis(6,3).
2
```

## Сопоставление с образцом



# Ссылки на источники

1. [Erlang для самых маленьких. Глава 1: Типы данных, переменные, списки и кортежи](https://habr.com/ru/post/195542/).
2. [Erlang для самых маленьких. Глава 2: Модули и функции](https://habr.com/ru/post/197364/).
3. [Erlang для самых маленьких. Глава 3: Базовый синтаксис функций](https://habr.com/ru/post/211815/)
4. [Программирование на Эрланге](https://dyp2000.gitbooks.io/russian-armstrong-erlang/content/).
5. [Начала работы с Erlang](http://rsdn.org/article/erlang/GettingStartedWithErlang.xml).